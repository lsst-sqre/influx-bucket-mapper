#!/usr/bin/env python3
import asyncio
import os
from dataclasses import asdict, dataclass, field
from datetime import timedelta
from typing import Any, Dict, List, Union

import aiohttp

# InfluxDB2 defaults

DEFAULT_URL = "http://localhost:8086"
DEFAULT_ORG = "default"

# Simple typealiases to represent InfluxDB v2 object fields
# Unless otherwise specified, they can be found at:
#      https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets
# "self" doesn't work as an object attribute, unsurprisingly.
# The problem with "RetentionRule" appears to be in aiohttp unmarshalling.

RetentionRule = Dict[str, Union[int, str]]
"""An InfluxDB v2 RetentionRule.  Valid keys:
* everySeconds: int
* shardGroupDurationSeconds: int
* type: str
"""

BucketLinks = List[Dict[str, str]]
"""Links for a Bucket object.  Valid keys (all str):
* labels
* members
* org
* owners
* self
* write
"""

URILinks = List[Dict[str, str]]
"""Links for a paginated InfluxDB v2 object.  Valid keys:
* self
* next
* prev
"""

# Some dataclasses to represent InfluxDB v2 objects
# Unless otherwise specified, they can be found at:
#      https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets


@dataclass
class Label:
    """An InfluxDB Label."""

    id: str = ""
    name: str = ""
    orgId: str = ""
    properties: Dict[str, str] = field(default_factory=dict)


@dataclass
class BucketGet:
    """An InfluxDB v2 Bucket, as returned from
    https://docs.influxdata.com/influxdb/v2.2/api/#operation/GetBuckets
    """

    createdAt: str = ""
    description: str = ""
    id: str = ""
    orgID: str = ""
    updatedAt: str = ""
    labels: list[Label] = field(default_factory=list)
    links: list[BucketLinks] = field(default_factory=list)
    name: str = ""
    retentionRules: list[RetentionRule] = field(default_factory=list)
    type: str = "user"


@dataclass
class DBRPGet:
    """An InfluxDB v2 DBRP, as you'd receive it when listing them.
    https://docs.influxdata.com/influxdb/cloud/api/#operation/GetDBRPs
    """

    bucketID: str
    database: str
    default: bool
    id: str
    orgID: str
    retention_policy: str
    links: list[URILinks] = field(default_factory=list)


@dataclass
class DBRPPost:
    """An InfluxDB v2 DBRP, as you'd send it when creating one:
    https://docs.influxdata.com/influxdb/cloud/api/#operation/PosttDBRPs

    We assume you're going to use the org name rather than the orgID.
    """

    bucketID: str
    database: str
    org: str
    retention_policy: str
    default: bool = False


class BucketMapper:
    """This is the class that does the work of querying InfluxDB v2 for its
    buckets, determining if buckets lack corresponding DBRPs, and creating
    those if needed.  It is designed to be used as a context manager in an
    ``async with`` clause.

    It wants the same InfluxDBv2 environment variables as InfluxDBv2 or
    Chronograf:
    * INFLUXDB_TOKEN
    * INFLUXDB_URL
    * INFLUXDB_ORG

    """

    def __init__(
        self,
        token: str = os.getenv("INFLUXDB_TOKEN") or "",
        url: str = os.getenv("INFLUXDB_URL") or DEFAULT_URL,
        org: str = os.getenv("INFLUXDB_ORG") or DEFAULT_ORG,
    ) -> None:
        assert token, "INFLUXDB_TOKEN or token param must be set"
        self.org = org
        self.api_url = url + "/api/v2"
        self.loop = asyncio.get_event_loop()
        self.params = {"org": self.org}
        self.session = aiohttp.ClientSession()
        self.session.headers.update({"Authorization": f"Token {token}"})

    async def __aenter__(self):
        return self

    async def __aexit__(self, *excinfo):
        if self.session:
            await self.session.close()

    async def list_buckets(self) -> List[BucketGet]:
        next = f"{self.api_url}/buckets"
        b_list = []
        while next:
            resp = await self.session.get(next, params=self.params)
            obj = await resp.json()
            b_list.extend(obj["buckets"])
            next = ""
            if "links" in obj and "next" in obj["links"]:
                next = obj["links"]["next"]
        return [BucketGet(**x) for x in b_list]

    async def list_dbrps(self) -> List[DBRPGet]:
        async def get_dbrp_page(uri: str) -> List[Dict[str, Any]]:
            resp = await self.session.get(uri, params=self.params)
            obj = await resp.json()
            return obj["content"]

        d_list: List[Dict[str, Any]] = []
        next = f"{self.api_url}/dbrps"
        while next:
            obj = await get_dbrp_page(next)
            if not obj:
                break
            d_list.extend(obj)
            next = ""
            if "links" in obj[-1] and "next" in obj[-1]["links"]:
                next = obj[-1]["links"]
        return [DBRPGet(**x) for x in d_list]

    async def prepare_buckets_without_dbrps(self) -> List[BucketGet]:
        """Generate a list of buckets whose corresponding DBRPs are missing"""
        buckets = await self.list_buckets()
        dbrps_ids = [x.bucketID for x in await self.list_dbrps()]
        missing_buckets = [x for x in buckets if x.id not in dbrps_ids]
        return missing_buckets

    def make_dbrp_from_bucket(self, bucket: BucketGet) -> DBRPPost:
        """Given a bucket, construct a DBRP object for it."""

        def seconds_to_duration_literal(seconds: int) -> str:
            """You'd really think this would be a library function already.

            Weirdly, although InfluxDB v2 lets you specify this down to
            nanoseconds, the object you get back from the API call only has
            second precision.
            """
            if seconds == 0:
                return "infinite"
            dls = ""
            duration = timedelta(seconds=seconds)
            if duration.days:
                weeks = duration.days // 7
                days = duration.days - weeks * 7
                if weeks:
                    dls += f"{weeks}w"
                if days:
                    dls += f"{days}d"
            if duration.seconds:
                hours = duration.seconds // (60 * 60)
                minutes = (duration.seconds - hours * 60 * 60) // 60
                secs = (duration.seconds - hours * 60 * 60) - minutes * 60
                if hours:
                    dls += f"{hours}h"
                if minutes:
                    dls += f"{minutes}m"
                if secs:
                    dls += f"{secs}s"
            return dls

        def get_retention_policy(bucket: BucketGet) -> str:
            """Construct a retention policy name from an expiration policy
            on a bucket.
            """
            rr = bucket.retentionRules
            for r in rr:
                # It's a list...I guess we use the first expire we find?
                # Is it guaranteed to only have one?
                if r["type"] != "expire":
                    continue
                break
            assert type(r["everySeconds"]) is int, "everySeconds is not an int"
            return seconds_to_duration_literal(r["everySeconds"])

        return DBRPPost(
            bucketID=bucket.id,
            database=bucket.name,
            default=True,
            org=self.org,
            retention_policy=get_retention_policy(bucket),
        )

    async def prepare_new_dbrps(self) -> List[DBRPPost]:
        """Generate a list of DBRPs to create"""
        # fmt: off
        return [
            self.make_dbrp_from_bucket(x)
            for x in await self.prepare_buckets_without_dbrps()
        ]
        # fmt: on

    async def create_new_dbrps(self) -> None:
        """Create DBRPs in InfluxDB v2"""
        dbrps = await self.prepare_new_dbrps()
        payloads = [asdict(x) for x in dbrps]
        # fmt: off
        payload_futs = [
            self.session.post(
                self.api_url + "/dbrps",
                json=x,
                params=self.params)
            for x in payloads]
        # fmt: on
        await asyncio.gather(*payload_futs)


def main() -> None:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(async_main())


async def async_main() -> None:
    async with BucketMapper() as bm:
        await bm.create_new_dbrps()


if __name__ == "__main__":
    main()
